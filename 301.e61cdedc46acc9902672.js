"use strict";(self.webpackChunkthree_shader_env01=self.webpackChunkthree_shader_env01||[]).push([[301,682],{682(n,t,e){e.r(t),e.d(t,{default:()=>o});var i=e(437),a=e(24);class o{constructor(n){this.canvas=n,this.isRunning=!1,this.sizes={width:window.innerWidth,height:window.innerHeight},this.cameraScale=2,this.timeoutId=null,this.targetCameraPosition=new i.Pq0,this.targetCameraW=0,this.init()}init(){this.initScene(),this.initGeometry(),this.initMaterial(),this.initPoints(),this.initRenderer(),this.initControls(),this.clock=new i.zD7,this.resize=this.resize.bind(this),window.addEventListener("resize",this.resize),window.addEventListener("orientationchange",this.resize),this.resize(),this.canvas.addEventListener("click",()=>this.refresh()),this.start(),this.smoothTransitionCamera()}initScene(){this.scene=new i.Z58,this.camera=new i.ubm(45,this.sizes.width/this.sizes.height,.1,1e3),this.camera.position.set(0,0,0),this.scene.add(this.camera)}initGeometry(){this.hyperSphere=new i.LoY;const n=3e5,t=new Float32Array(9e5);for(let n=0;n<9e5;n++)t[n]=2*(Math.random()-.5);this.hyperSphere.setAttribute("position",new i.THS(t,3));const e=new Float32Array(12e5);for(let t=0;t<n;t++){const n=2*Math.random()-1,i=-Math.sqrt(1-n*n),a=Math.sqrt(1-n*n),o=i+Math.random()*(a-i),r=-Math.sqrt(1-n*n-o*o),s=Math.sqrt(1-n*n-o*o),c=r+Math.random()*(s-r),l=Math.sqrt(1-n*n-o*o-c*c);e[4*t+0]=n,e[4*t+1]=o,e[4*t+2]=c,e[4*t+3]=l}this.hyperSphere.setAttribute("aaaa",new i.THS(e,4))}initMaterial(){this.material=new i.BKk({vertexShader:"varying vec4 newColor;\n\n// // Attributes\n// attribute vec4 instanceValue;\n// attribute vec4 instanceNoise;\n// attribute vec4 perHyperCube;\n// attribute vec4 position4D;\nattribute vec4 aaaa;\n\n// //uniforms\nuniform float uTime;\nuniform float aspectRatio;\nuniform float cameraW;\nuniform float u_WScale;\n\n// Stereographic Projection Matrix\nvec4 stereographicProjection(vec4 point) {\n    float scale = 1.0;\n    mat4 projectionMatrix = mat4(\n        scale / (scale - point.w), 0.0, 0.0, 0.0,\n        0.0, scale / (scale - point.w), 0.0, 0.0,\n        0.0, 0.0, scale / (scale - point.w), 0.0,\n        0, 0, 0, 1.0\n    );\n    vec4 projectedPoint = projectionMatrix * vec4(point.xyz, 1.0);\n    return projectedPoint;\n}\n\nmat4 createViewMatrix3D(vec3 cameraPosition, vec3 targetPosition, vec3 upVector) {\n    vec3 forward = normalize(targetPosition - cameraPosition);\n    vec3 right = normalize(cross(forward, upVector));\n    vec3 up = cross(right, forward);\n    mat4 viewMatrix = mat4(\n        right.x, up.x, -forward.x, 0.0,\n        right.y, up.y, -forward.y, 0.0,\n        right.z, up.z, -forward.z, 0.0,\n        -dot(right, cameraPosition), -dot(up, cameraPosition), dot(forward, cameraPosition), 1.0\n);\n    return viewMatrix;\n}\n\nmat4 perspectiveProjectionMatrix(float fovY, float aspect, float zNear, float zFar) {\n    float tanHalfFovY = tan(fovY / 2.0);\n    mat4 projectionMatrix = mat4(\n        1.0 / (aspect * tanHalfFovY), 0, 0, 0,\n        0, 1.0 / tanHalfFovY, 0, 0,\n        0, 0, -(zFar + zNear) / (zFar - zNear), -1,\n        0, 0, -2.0 * zFar * zNear / (zFar - zNear), 0);\n    return projectionMatrix;\n}\n\n\n// // HyperCube Translation\n// vec4 hyperCubeTranslation(vec4 inputPosition, vec4 instanceValue) {\n//     vec4 newPosition;\n//     newPosition.x = (instanceValue.x == 1.0) ? inputPosition.x :\n//                     (instanceValue.x == 2.0) ? inputPosition.y :\n//                     instanceValue.x;\n//     newPosition.y = (instanceValue.y == 1.0) ? inputPosition.x :\n//                     (instanceValue.y == 2.0) ? inputPosition.y :\n//                     instanceValue.y;\n//     newPosition.z = (instanceValue.z == 1.0) ? inputPosition.x :\n//                     (instanceValue.z == 2.0) ? inputPosition.y :\n//                     instanceValue.z;\n//     newPosition.w = (instanceValue.w == 1.0) ? inputPosition.x :\n//                     (instanceValue.w == 2.0) ? inputPosition.y :\n//                     instanceValue.w;\n//     return newPosition;\n// }\n\n// Orthographic Projection Matrix Function\n// mat4 orthoProjectionMatrix(float left, float right, float bottom, float top, float nearClip, float farClip) {\n//     mat4 projectionMatrix = mat4(\n//         2.0 / (right - left), 0, 0, -(right + left) / (right - left),\n//         0, 2.0 / (top - bottom), 0, -(top + bottom) / (top - bottom),\n//         0, 0, -2.0 / (farClip - nearClip), -(farClip + nearClip) / (farClip - nearClip),\n//         0, 0, 0, 1\n//     );\n//     return projectionMatrix;\n// }\n\n// Rodrigues rotation???\n// vec4 rotate4D(vec4 originalPos, float angle, vec4 axis) {\n//     float halfAngle = angle / 2.0;\n//     float sinHalfAngle = sin(halfAngle);\n    \n//     // Create the quaternion representing the rotation\n//     vec4 quaternion = vec4(cos(halfAngle), axis.x * sinHalfAngle, axis.y * sinHalfAngle, axis.z * sinHalfAngle);\n\n//     // Normalize the quaternion\n//     float qLength = length(quaternion);\n//     quaternion /= qLength;\n\n//     // Calculate the conjugate of the quaternion\n//     vec4 conjugate = vec4(quaternion.x, -quaternion.y, -quaternion.z, -quaternion.w);\n\n//     // Perform the quaternion rotation\n//     vec4 rotatedPos = quaternion * originalPos * conjugate;\n    \n//     return rotatedPos;\n// }\n\nvoid main() {\n    \n    // DUPLICATION\n    // vec4 newPosition = hyperCubeTranslation(vec4(position,0.0), instanceValue);\n    // vec4 newPosition = pos4D;\n    // newPosition.w *= u_WScale;\n\n    // vec4 newPosition = normalize(aaaa);\n    vec4 newPosition = aaaa;\n    newPosition.w *= u_WScale;\n\n    // ROTATIONs\n    float time = uTime / 3.0;\n    // 2:XY\n    newPosition *= mat4(\n        1, 0, 0, 0,\n        0, 1, 0, 0,\n        0, 0, cos(time), -sin(time),\n        0, 0, sin(time), cos(time)\n    );\n    // 3:XW\n    newPosition *= mat4(\n        1, 0, 0, 0,\n        0, cos(time), -sin(time), 0,\n        0, sin(time), cos(time), 0,\n        0, 0, 0, 1\n    );\n    // 5: YZ\n    newPosition *= mat4(\n        cos(time), 0, 0, -sin(time),\n        0, 1, 0, 0,\n        0, 0, 1, 0, \n        sin(time), 0, 0, cos(time)\n    );\n\n    // float angle = sin(time);\n    // newPosition = rotate4D(newPosition, angle, normalize(vec4 (0, 0, 1.0, 0)));\n\n\n    newPosition = normalize(newPosition);\n\n    // newPosition += perHyperCube;\n\n    vec4 positionConv = stereographicProjection(newPosition);\n    vec4 cameraPositionConv = stereographicProjection(vec4(cameraPosition.xyz, cameraW * u_WScale));\n\n    // float nearClip =0.005;\n    // float farClip  =100.0;\n    // float lensAngle =100.0;\n    // float top = nearClip * tan(radians(lensAngle) / 2.0);\n    // float bottom = -top;\n    // float right = top * aspectRatio;\n    // float left = -right;\n    // mat4 orthMat = orthoProjectionMatrix(left, right, bottom, top, nearClip, farClip);\n\n    mat4 viewMat = createViewMatrix3D(cameraPositionConv.xyz, vec3(0), vec3(0, 1.0, 0));\n    mat4 persMat = perspectiveProjectionMatrix(radians(80.0),aspectRatio, 0.01, 1000.0);\n    // gl_Position = projectionMatrix * modelViewMatrix * vec4(normalize(position) * 0.5, 1.0);\n    // gl_Position = persMat * viewMat * vec4(position , 1.0);\n    // gl_Position = projectionMatrix * modelViewMatrix * vec4(position , 1.0);\n    gl_Position = persMat * viewMat * positionConv;\n    // gl_Position = orthMat * viewMat * positionConv;\n    // gl_PointSize = (0.3 / (gl_Position.w == 0.0 ? 0.001 : gl_Position.w/10.0));\n    gl_PointSize = 2.0 / (gl_Position.w == 0.0 ? 0.001 : gl_Position.w);\n\n    // newColor = vec4(aaaa);\n    // newColor = vec4((positionConv.xyz + 1.0) / 2.0, 1.0);\n    // newColor = vec4((newPosition.xyz + 1.0) / 2.0, 1.0);\n    // newColor = vec4(abs(normalize(cameraPositionConv.xyz))/2.0 + (newPosition.xyz + 1.0)/4.0, 1.0);\n    newColor = vec4(abs(normalize(cameraPositionConv.xyz))/2.0 + abs(newPosition.xyz)/2.0, 1.0);\n    // newColor = vec4(abs(normalize(cameraPositionConv.xyz)) , 1.0);\n    // newColor = vec4(abs(newPosition.xyz), 1.0);\n    }\n    \n\n\n\n\n\n\n\n\n\n\n",fragmentShader:"varying vec4 newColor;\n\nvoid main() {\n    // gl_FragColor = vec4(1.0);\n    // gl_FragColor = vec4(0.8);\n    gl_FragColor = abs(newColor);\n    float len = length(gl_PointCoord - 0.5);\n    if(len >= 0.5) discard; \n    gl_FragColor.a = 0.7;\n    }   \n",transparent:!0,depthTest:!1,blending:i.NTi,uniforms:{uTime:{value:0},aspectRatio:{value:this.sizes.width/this.sizes.height},cameraW:{value:0},u_aspect:{value:this.camera.aspect},u_angle:{value:this.camera.fov},u_near:{value:this.camera.near},u_far:{value:this.camera.far},u_WScale:{value:.5}}}),this.targetCameraW=this.material.uniforms.cameraW.value}initPoints(){this.mesh=new i.ONl(this.hyperSphere,this.material),this.scene.add(this.mesh)}initRenderer(){this.renderer=new i.JeP({canvas:this.canvas}),this.renderer.setPixelRatio(Math.min(window.devicePixelRatio,2))}initControls(){this.controls=new a.N(this.camera,this.canvas),this.controls.enableDamping=!0}resize(){this.sizes.width=window.innerWidth,this.sizes.height=window.innerHeight,this.camera.aspect=this.sizes.width/this.sizes.height,this.camera.updateProjectionMatrix(),this.material.uniforms.aspectRatio.value=this.sizes.width/this.sizes.height,this.renderer.setSize(this.sizes.width,this.sizes.height)}smoothTransitionCamera(){const n=this.targetCameraPosition.clone().sub(this.camera.position);this.camera.position.add(n.multiplyScalar(.01));const t=this.targetCameraW-this.material.uniforms.cameraW.value;this.material.uniforms.cameraW.value+=.01*t,requestAnimationFrame(()=>this.smoothTransitionCamera())}refresh(){const n=2*Math.random()-1,t=2*Math.random()-1,e=2*Math.random()-1;this.targetCameraPosition.set(n*this.cameraScale,t*this.cameraScale,e*this.cameraScale),this.targetCameraW=2*Math.random()-1;const i=Math.floor(3e3*Math.random())+5500;clearTimeout(this.timeoutId),this.timeoutId=setTimeout(()=>this.refresh(),i)}animate(){if(!this.isRunning)return;const n=this.clock.getElapsedTime();this.material.uniforms.uTime.value=n,this.controls.update(),this.renderer.render(this.scene,this.camera),requestAnimationFrame(()=>this.animate())}start(){this.isRunning||(this.isRunning=!0,this.clock.start(),this.animate(),this.refresh())}stop(){this.isRunning=!1,this.clock.stop()}destroy(){this.stop(),clearTimeout(this.timeoutId),window.removeEventListener("resize",this.resize),window.removeEventListener("orientationchange",this.resize),this.controls.dispose(),this.renderer.dispose()}}}}]);