"use strict";(self.webpackChunkthree_shader_env01=self.webpackChunkthree_shader_env01||[]).push([[174,793],{790(t,i,e){e.r(i),e.d(i,{default:()=>a});var n=e(437);const o=e.p+"assets/images/6d5145778269b60f6f72.jpeg";class a{constructor(t){this.canvas=t,this.isRunning=!1,this.sizes={width:window.innerWidth,height:window.innerHeight},this.targetCameraPosition=new n.Pq0,this.targetXyRatio=.342,this.targetSScale=-39.61,this.targetTScale=40.07,this.timeoutId=null,this.init()}init(){this.initScene(),this.initInstances(),this.initRenderer(),this.clock=new n.zD7,this.elapsedTime=0,this.start(),this.smoothTransitionCamera(),this.refresh()}initScene(){this.scene=new n.Z58,this.camera=new n.ubm(45,this.sizes.width/this.sizes.height,.1,100),this.camera.position.set(.6,.6,1.5),this.scene.add(this.camera);const t=new n.Tap;this.texture=t.load(o),this.geometry=new n.bdM(1,1,1,100),this.material=new n.BKk({vertexShader:"varying vec4 newColor;\nvarying vec2 vUv;\n// // Attributes\nattribute vec4 translationVec;\nattribute vec4 rotationVec;\nattribute vec4 instanceNoise;\n\n// //uniforms\nuniform float uTime;\nuniform float aspectRatio;\nuniform float xyRatio;\nuniform float sScale;\nuniform float sScaleMin; \nuniform float tScale;\nuniform float cameraW;\n\n// Swap Matrix\nvec4 swapMatrix(vec4 inputPosition, vec4 rotationVec) {\n    mat4 swapFunction = mat4(\n        ((rotationVec.x == 1.0) ? 1.0 : 0.0),\n        ((rotationVec.y == 1.0) ? 1.0 : 0.0),\n        ((rotationVec.z == 1.0) ? 1.0 : 0.0),\n        ((rotationVec.w == 1.0) ? 1.0 : 0.0),\n        ((rotationVec.x == 2.0) ? 1.0 : 0.0),\n        ((rotationVec.y == 2.0) ? 1.0 : 0.0),\n        ((rotationVec.z == 2.0) ? 1.0 : 0.0),\n        ((rotationVec.w == 2.0) ? 1.0 : 0.0),\n        ((rotationVec.x == 3.0) ? 1.0 : 0.0),\n        ((rotationVec.y == 3.0) ? 1.0 : 0.0),\n        ((rotationVec.z == 3.0) ? 1.0 : 0.0),\n        ((rotationVec.w == 3.0) ? 1.0 : 0.0),\n        ((rotationVec.x == 4.0) ? 1.0 : 0.0),\n        ((rotationVec.y == 4.0) ? 1.0 : 0.0),\n        ((rotationVec.z == 4.0) ? 1.0 : 0.0),\n        ((rotationVec.w == 4.0) ? 1.0 : 0.0)\n    );\n    return vec4 (swapFunction * inputPosition);\n}\n\n// Orthographic Projection Matrix Function\nmat4 orthoProjectionMatrix(float left, float right, float bottom, float top, float nearClip, float farClip) {\n    mat4 projectionMatrix = mat4(\n        2.0 / (right - left), 0, 0, -(right + left) / (right - left),\n        0, 2.0 / (top - bottom), 0, -(top + bottom) / (top - bottom),\n        0, 0, -2.0 / (farClip - nearClip), -(farClip + nearClip) / (farClip - nearClip),\n        0, 0, 0, 1\n    );\n    return projectionMatrix;\n}\n\nvoid main() {\n\n    // DUPLICATION\n    vec4 scaleNoise = vec4(instanceNoise.w * xyRatio, instanceNoise.z, 1.0, 1.0) * sScale;\n    vec4 newPosition = swapMatrix(vec4(position, 0.0) * (scaleNoise + sScaleMin) + translationVec * tScale, rotationVec);\n    // position: original plane position in 3D\n    // scaleNoise + alpha: scaling original plane incl W with min value alpha\n    // translationVec: changing the modified planes' position (translating), higher value, more spread\n    // rotating those planes by rotationVec (just angles)\n\n    // ROTATIONs\n    // 2:XY\n    float time = uTime / 20.0;\n    newPosition *= mat4(\n        1, 0, 0, 0,\n        0, 1, 0, 0,\n        0, 0, cos(time), -sin(time),\n        0, 0, sin(time), cos(time)\n    );\n    // 3:XW\n    newPosition *= mat4(\n        1, 0, 0, 0,\n        0, cos(time), -sin(time), 0,\n        0, sin(time), cos(time), 0,\n        0, 0, 0, 1\n    );\n    // 5: YZ\n    newPosition *= mat4(\n        cos(time), 0, 0, -sin(time),\n        0, 1, 0, 0,\n        0, 0, 1, 0, \n        sin(time), 0, 0, cos(time)\n    );\n\n    // newPosition.w = -20.0;\n\n    //VIEW MATRIX\n    float nearClip =0.005;\n    float farClip  =100.0;\n    float lensAngle =40.0;\n    vec4 lookAt = vec4(0);\n    vec4 modCamPos = vec4(cameraPosition.xyz * 10.0, cameraW * 25.0);\n    // Calculate the 4D lookAtDirection\n    vec3 lookAtDirection = normalize(lookAt.xyz - modCamPos.xyz);\n    vec3 rightVec = normalize(cross(vec3(0, 1, 0), lookAtDirection));\n    vec3 upVec = cross(lookAtDirection, rightVec);\n\n    mat4 viewMatrix4D = mat4(\n        vec4(rightVec, -dot(rightVec, modCamPos.xyz)),\n        vec4(upVec, -dot(upVec, modCamPos.xyz)),\n        vec4(-lookAtDirection, dot(lookAtDirection, modCamPos.xyz)),\n        vec4(0, 0, 0, 1)\n    );\n    viewMatrix4D[3][3] = modCamPos.w - lookAt.w;\n    viewMatrix4D[3][2] = lookAt.w;\n\n    // TRANSFORMATION\n    mat4 transformMatrix = mat4(\n        1, 0, 0, 0,\n        0, 1, 0, 0,\n        0, 0, 1, 0,\n        0, 0, 0, newPosition.w - modCamPos.w \n    );\n    \n    // Apply the transformation to the 4D point\n    vec4 transformedPosition = transformMatrix * newPosition;\n\n    // // PROJECTION\n    float top = nearClip * tan(radians(lensAngle) / 2.0);\n    float bottom = -top;\n    float right = top * aspectRatio;\n    float left = -right;\n\n    mat4 orthoProjection = orthoProjectionMatrix(left, right, bottom, top, nearClip, farClip);\n    mat4 ModelViewProjectionMatrix4Db = orthoProjection * viewMatrix4D;\n    vec4 projection4Db = ModelViewProjectionMatrix4Db * transformedPosition;\n    gl_Position = projection4Db;        \n\n    // newColor = instanceNoise * vec4(0.6, 0.9, 1.0, 1.0) + vec4(normalize(newPosition.xyz), 1.0)/ 0.8;\n    // newColor = instanceNoise * vec4(0.6, 0.9, 1.0, 1.0) + vec4(normalize(newPosition.xyz), 1.0)/ 1.8;\n    // newColor = instanceNoise.xyz;\n    vUv = uv;\n    }\n    \n\n\n\n\n\n\n\n\n\n\n",fragmentShader:"varying vec4 newColor;\nvarying vec2 vUv;\n\nuniform sampler2D uTexture;\n\nvoid main() {\n    vec4 textureColor = texture2D(uTexture, vUv);\n    // gl_FragColor = vec4(0.5, 0.5, 0.5, 0.2);\n    // gl_FragColor = textureColor/2.0 + newColor/6.0;\n    gl_FragColor = vec4(textureColor.g, textureColor.g, textureColor.b, 0.12);\n    // gl_FragColor.a = 0.1;\n    }   \n",transparent:!0,depthTest:!1,blending:n.NTi,uniforms:{uTime:{value:0},uTexture:{value:this.texture},aspectRatio:{value:this.sizes.width/this.sizes.height},xyRatio:{value:.342},sScale:{value:-39.61},sScaleMin:{value:24.133},tScale:{value:40.07},cameraW:{value:0}},wireframe:!0,linewidth:.001})}initInstances(){this.instanceCount=240;const t=[];for(let i=0;i<this.instanceCount;i++)t.push(2*(Math.random()-.5),2*(Math.random()-.5),2*(Math.random()-.5),2*(Math.random()-.5));this.geometry.setAttribute("translationVec",new n.uWO(new Float32Array(t),4));const i=[];for(let t=0;t<this.instanceCount;t++)i.push(Math.random(),Math.random(),Math.random(),Math.random());this.geometry.setAttribute("instanceNoise",new n.uWO(new Float32Array(i),4));const e=[],o=[1,2,3,4];for(let t=0;t<10;t++)for(let t=0;t<o.length;t++)for(let i=0;i<o.length;i++)if(i!==t)for(let n=0;n<o.length;n++)if(n!==t&&n!==i)for(let a=0;a<o.length;a++)a!==t&&a!==i&&a!==n&&e.push(o[t],o[i],o[n],o[a]);this.geometry.setAttribute("rotationVec",new n.uWO(new Float32Array(e),4)),this.mesh=new n.ZLX(this.geometry,this.material,this.instanceCount),this.scene.add(this.mesh)}initRenderer(){this.renderer=new n.JeP({canvas:this.canvas}),this.resize()}resize(){this.sizes.width=window.innerWidth,this.sizes.height=window.innerHeight,this.camera.aspect=this.sizes.width/this.sizes.height,this.camera.updateProjectionMatrix(),this.material.uniforms.aspectRatio.value=this.sizes.width/this.sizes.height,this.renderer.setSize(this.sizes.width,this.sizes.height),this.renderer.setPixelRatio(Math.min(window.devicePixelRatio,2))}smoothTransitionCamera(){if(!this.isRunning)return;const t=.01,i=this.targetCameraPosition.clone().sub(this.camera.position);this.camera.position.add(i.multiplyScalar(t)),this.material.uniforms.xyRatio.value+=(this.targetXyRatio-this.material.uniforms.xyRatio.value)*t,this.material.uniforms.sScale.value+=(this.targetSScale-this.material.uniforms.sScale.value)*t,this.material.uniforms.tScale.value+=(this.targetTScale-this.material.uniforms.tScale.value)*t,this.material.uniforms.cameraW.value=Math.abs(this.camera.position.length()*(this.camera.position.x+this.camera.position.y+this.camera.position.z)),requestAnimationFrame(()=>this.smoothTransitionCamera())}refresh(){const t=Math.random();if(t<.65){const t=2*Math.random()-1,i=2*Math.random()-1,e=1.4*Math.random()-.7+(Math.random()<.5?-.3:.3);this.targetCameraPosition.set(t,i,e)}t>.55&&(this.targetXyRatio=2*Math.random()-1,this.targetSScale=80*(2*Math.random()-1),this.targetTScale=15*(2*Math.random()-1)+40);const i=Math.floor(5e3*Math.random())+3e3;clearTimeout(this.timeoutId),this.timeoutId=setTimeout(()=>this.refresh(),i)}animate(){this.isRunning&&(this.elapsedTime+=this.clock.getDelta(),this.material.uniforms.uTime.value=this.elapsedTime,this.renderer.render(this.scene,this.camera),requestAnimationFrame(()=>this.animate()))}start(){this.isRunning||(this.isRunning=!0,this.clock.start(),this.animate(),this.smoothTransitionCamera())}stop(){this.isRunning=!1,this.clock.stop()}destroy(){this.stop(),clearTimeout(this.timeoutId),this.renderer.dispose()}}}}]);